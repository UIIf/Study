\documentclass[14pt, titlepage,fleqn,a4paper]{extarticle}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage[russian]{babel}

% \usepackage{titlepage}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{float} 

\usepackage{caption}

%----------------------------------------------------
% \setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX\textbf{}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}

\usepackage{listings}
\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
}
%----------------------------------------------------

% \captionsetup[figure]{font=small}

\newcommand{\InsertGraf}[2]{
	\begin{figure}[H]
		\center{\includegraphics[width = \textwidth]{#1}}
		\caption{#2}
	\end{figure}
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}


\lstset{frame=tb,
	language=Python,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\title{Разработка прототипа игры жанра Top-Down Shooter на базе Unity}
\author{Uiif Ui}
\date{March 2022}

\begin{document}

    \maketitle
    %--------------------------------------------------------------------
	\tableofcontents   
	\setcounter{page}{1}
	\newpage
	%--------------------------------------------------------------------
	\section*{Введение}
	\addcontentsline{toc}{section}{Введение}


В последнее время все большие обороты набирает гейм индустрия, или индустрия компьютерных игр (сектор экономики, связанный с разработкой, продвижением и продажей компьютерных игр). Масштабы ее можно сравнить, например, с киноиндустрией. Но скорость роста гейм индустрии за последние пять лет все же существенно больше.

Некоторые компьютерные игры удивляют и даже признаются произведениями искусства. Количество игроков растет (в 2019 г. насчитывалось 2,5 млрд. игроков), а сам гейминг становится высокооплачиваемой профессией. 

Вокруг ядра, состоящего из разработчиков игр и издателей, развиваются профильные СМИ, специальные финансовые и рекламные инструменты; появляются специализированные физические площадки (интернет-кафе нового поколения, локации для кибертурниров и др.); разработке игр начинают обучать в высших учебных заведениях и др. Кроме того, занять свою нишу хотят и игроки со смежных рынков – производители электроники (например, Apple) или интернет-корпорации (например, Google), обладающие всеми ресурсами для вывода на рынок перспективных игровых решений.

Что касается ключевых тенденций, определяющих развитие глобальной игровой индустрии, то здесь, в первую очередь, необходимо отметить новые технологии: мобильные, облачные, виртуальные, графические, искусственный интеллект и др. Уже в течение нескольких лет компьютерные игры активно интегрируются в соцсети. Также появился и обратный тренд – они сами становятся своеобразными соцсетями. Растет популярность киберспорта.

Использование и применение компьютерных игр – это не только проведение досуга. Так же они могут быть использованы в сфере образования, науки, промышленности и в других сферах деятельности человека. 

Разработка игр - достаточно интересный вид деятельности. Университет дает достаточно знаний для того чтобы начать погружение в эту сферу.

Цель данной работы: применение знаний, полученных при обучении, на практике - создание прототипа будущего игрового проекта в жанре Top-down shooter при помощи Unity

Для достижения данной цели были поставлены следующие задачи:
\begin{itemize}
\item познакомиться с различными классификациями жанров компьютерных игр; 
\item освоить инструментальные средства;
\item создать прототип игры.
\end{itemize}
    \section*{Общая информация}
	\addcontentsline{toc}{section}{Общая информация}
	
	Компьютерные игры разделяются на жанры. Классификаций данных жанров большое множество.
К примеру, существует \textbf{классификация по Крофуорду}, где игры делятся на две большие группы: зависящие от навыка или от стратегии.
Эти группы в свою очередь  делятся на подгруппы.

	 \textbf{Зависящие от навыка:}
	\begin{itemize}
		\item Спортивные игры
		\item Гонки
		\item Лабиринты
		\item Игры с прямым соперничеством
	\end{itemize}

	\textbf{Стратегии:}
	\begin{itemize}
		\item Приключенчиские (акцент на самих приключениях)
		\item Фентезийные (акцент на мире)
		\item Военные игры (акцент на противостоянии)
		\item Игры основанные на случайности
	\end{itemize}

Так же интересно звучит \textbf{классификация по Шмелеву}.
Здесь игры делятся на :
\begin{itemize}
	\item Головоломки
	\item Азартные игры
	\item Управленческо-экономические
	\item и другие.
\end{itemize}

Наиболее распространенной, на мой взгляд, является \textbf{классификация по Орланду, Стейнбергу и Томасу}.
	Жанры:
	\begin{itemize}
		\item Action
		\item Adventure
		\item Role-playing
		\item Shoot 'em up
		\item и другие.
	\end{itemize}

\textbf{Shoot 'em up} - вид компьютерных игр, в которых главный персонаж, автоматически передвигаясь вперед по уровню, растреливает толпы противников, одновременно минуя препятствия. Отличаются неистовым темпом, основываются на показных боях с использованием оружия и большим количеством противников. 

В данном случае нас интереусет поджанр Shoot 'em up, известный как \textbf{Top-down shooter}. В основном эти игры отличаются способом перемещения персонажа: игроку дается больший контроль в управлении. Так же камера располоагается сверху, а стрельба ведется при помощи мыши. Наиболее известной игрой данного жанра является "Hotline Miami". Для создания собственной игры можно поизаимствовать строение карты, а именно то, что на карте отсутствуют просторные, открытые локации.

Проанализировав индустрию, заметим что все больше число игр обладают элементами поджанра RougLike.

\textbf{RougLike} - поджанр ролевых игр, характеризующийся спуском в случайно сгенерированное подземелье и окончательной смертью игрока.

Отсюда возьмем случайногененрируемую карту, что увеличит реиграбильность и удержание игры.

После всего этого можно составить дизайн- документ(документ, в котором будут содержаться основные идеи, которые должны быть реализованы в игре).
\\
\\
\textbf{Дизайн- документ}:
\begin{itemize}
	\item Высокая скорость перемещения
	\item Ограниченный боезапас для огнестрельного оружия (нет перезарядки, для оружия 2 ячейки, оружие выбрасывается и подбирается с пола новое)
	\item Выброшенное оружие при попадании во врага оглушает его
	\item Метательное оружие (гранаты)
	\item Полоска здоровья, здоровье врагов увеличивается по мере прохождения
    \item Чтобы завершить игру, игроку нужно найти несколько артефактов

	\item \textbf{Игровой мир:}
	Генерация мира(комнат) с удалением блоков, находящихся далеко от игрока 

	\item \textbf{Игровая механика:}
	Периодически случайным образом будут появляться комнаты с новым типом оружия, которое после взятия будет так же появляться у врагов

	\item \textbf{Интерфейс:}
	Количество здоровья, ячейки оружия, ячейка метательного оружия, количество патронов в выбранном оружии, если оно огнестрельное.

	\item \textbf{Враги:}
	Несколько типов врагов, отличающиеся количеством здоровья, внимательностью и скоростью перемещения
\end{itemize}
	\section*{Анализ технической части}
	\addcontentsline{toc}{section}{Анализ технической части}

    Задача этой работы - написать игру при помощи Unity. Что же это такое?

\textbf{Unity} - среда для разработки компьютерных игр. Одним из главных ее преимуществ является простота в использовании, а также межплатформенность. Поддерживаются более 20 платформ, от компьютеров под управлением Windows до интернет приложений.

Unity обладает удобным и понятным drag\&drop интерфейсом. Поддерживаются два языка C\# и JavaScript.

Структура:
	Проект делится на сцены(уровни) - отдельные файлы,содержащие свои объекты и сценарии.
	Объекты сцены содержат компоненты, с которыми взаимодействуют скрипты. Объекты обязаны иметь такие поля как имя, слой и тег, а так же компонент Transform, который отвечает за положение в пространстве. Слои отвечают, например, за физику. В настройках можно определить, какие слои пересекаются при симуляции физики. При помощи имени или тега можно находить или отличать объекты на сцене. Так же у объектов с видимым представлением есть компонент MeshRenderer, который отвечает за отрисовку модели на экране.

	Для симуляции столкновений в Unity объекту необходимо добавить физическое отображение(Collider). В зависимости от назначения объекта это физическое отображение может быть более или менее точным. Для 3D варианта есть несколько основных типов - прямоугольный, капсула, сфера или же mesh collider. В последнем случае Unity  создает коллайдер, основываясь на 3D модели, желательно не использовать этот вариант. В сложных случаях можно использовать несколько прямоугольных коллайдеров, в целях оптимизации вычисления.

Так же в Unity уже встроены такие мощные интрументы как карты нормалей и динамическое освещение.

Немного об исполнении проекта.
Каждый объект наследуется от класса MonoBeheaviour, в котором есть встроенные функции.
	Основные функции класса MonoBehaviour:
	\begin{itemize}
	\item Start - вызывается в кадр, когда объект включается 
	\item Awake - вызывается, когда объект класса загружен
	\item Update - вызывается каждый кадр, когда объект включен
	\item FixedUpdate - вызывается независимо от обновления кадров с постоянным шагом во времени. Здесь же обрабатывается физика.
    \end{itemize}
Так же в Unity есть удобный инструмент - Coroutine. Он позволяет сделать вид многопоточности при использовании одного потока.

    \section*{Подготовка к реализации}
	\addcontentsline{toc}{section}{Подготовка к реализации}
	
	Изначально разработку было решено разбить на подгруппы:
	\begin{itemize}
	\item Разработка движения камеры
	\item Разработка генератора карты
	\item Разработка противников
	\item Разработка оружия
	\end{itemize}
	
	Далее было необходимо вообразить и описать каждую из механик, чтобы их было проще реализовывать в коде.
	
	Такой подход сильно облегчит работу в будущем.
	
	\subsection*{Камера}
	\addcontentsline{toc}{subsection}{Работа с камерой}
	
	В большинстве Top-down шутеров камера зафиксирована сверху, что делает мир игры плоским и невыделяющимся. При реализации камера должна будет передвигаться от игрока к прицелу, на определенный процент расстояния между ними. Таким образом, даже стоя на одном месте можно будет увидеть карту с разных сорон.
	
	В тоже время, так как камера будет предвигаться динамически, следовательно, поле зрения игрока будет двигаться, нельзя допустить, чтобы камера смещалась дальше определенного расс,тояния, иначе можно будет улететь за край сгенерированной части карты.
	
	\subsection*{Процедурная карта}
	\addcontentsline{toc}{subsection}{Создание процедурной карты}
	
	Самым важным элементом данного прототипа является процедурно сгенерированная карта. Она поможет увеличить вариативность при прохождении.
	
	Для начало было решено, что карта будет состоять из блоков одинакового размера, что облегчит их расставление по карте. Благодаря выбранной стилистике, блоки было решено делать ввиде квартир.
	
	Квартира состоит из внешних и внутренних стен, мебели, дверей, а так же различных обоев и покрытий полов.
	
	Дальше было решено предварительно сделать несколько видов каждой из составляющей комнаты, чтобы при создании новой, просто набирать элементы из уже заготовленных.
	
	Таким образом из относительно небольшого количества заготовленных частей получится сделать отличаюсщиеся друг от друга квартиры.
	
	Так же необходимо помнить о специализированных комнатах, в которых будет появляться оружие.
	При появлении такой комнаты, она должна быть одна, на сгенерированной карте. Так как в ней по задумке должны отсутствовать противники, игроку хотелось бы окружить себя как можно большим количеством этих квартир, но при появлении одной за раз игроку прийдется отходить все дальше и дальше, что подтолкнет его на исследование.
	
	Для генерации таких комнат будет необходимо всего лишь поменять внутренние стены и мебель при генерации квартиры.
	
	Так же необходимо помнить что, желательно сократить использование памяти в игре, поэтому будет необходимо удалять комнаты (и их содержимое), которые находятся дальше остальных.
	
	\subsection*{Противники}
	\addcontentsline{toc}{subsection}{Создание противников}
	
	Далее необходимо представить, как будут устроены противники.
	
	Опишем предполагаемое поведение противника.
	Изначально npc патрулирует свою комнату. Если в поле зрения попадает игрок, начинает преследование, а именно, идет в сторону игрока до тех пор, пока расстояние  между противником и игроком не будет меньше определенного значения. Когда расстояние меньше или равно, противник начинает стрелять. В случае же, если игрок скрылся из поля зрения, противник бежит к последнему месту, где находился игрок, и там оглядывается некоторое время, после чего снова переходит в режим патрулирования. Так же при стрельбе, если противник находится достаточно близко, то он "слышит" выстрелы и бежит в их сторону.

    "Зрение противника":
    Зрение противника будет ограничено по дальности, а так же будет ограничен угол обзора, однако если же подойти слишком близко, противник сможет увидеть игрока.

    \subsection*{Оружие}
	\addcontentsline{toc}{subsection}{Создание оружия}
	
	При создании оружия необходимо сделать так, чтобы добавления новых типов и новых экзмепляров было как можно проще.
	
	Также одно и то же оружие должно работать, как в руках игрока, так и в руках противника.
	
	Основным типом оружия будет снаряжение, основанное на лучах, из-за того, что просчитывать лучи куда проще, чем любой другой способ.
	
    \section*{Реализация}
	\addcontentsline{toc}{section}{Реализация}
	\subsection*{Камера}
	\addcontentsline{toc}{subsection}{Работа с камерой}
	Разработку игры было решено начать с создания камеры. 
	
	Для реализации был создан CamScript.

    \textbf{Приложение (Листинг 1: Основная функция камеры)}
    В нем при каждом FixedUpdate вызывается функция отвечающая за логику перемещения камеры. В этой функции создается плоскость находящяся на уровне точки откуда стреляет игрок. 
    
    Дальше при помощи Camera.main.ScreenPointToRay, создается луч который исходит из главной камеры и сонаправлени с вектором который задается разностью проекции курсора мыши на игровое пространство и позицией главной камеры.
    
    В дальнейшем процессе разработки была выявленна проблема, а именно, при стрельбе, строится луч по направлению от ствола оружия, до точки куда целится игрок, что на большой длинне данного вектора выглядит приемлимо, но если завести курсор между оружием и игроком, он может выстрелить сам в себя. Пришлось добавлять внутреннее ограничение, за которое точка прицела зайти не можт.
    
    Если расстояние между точкой и игроком меньше установленной длины, то находится нормализованный вектор направления от игрока к прицелу, умножается на необходимое расстояние и прибавляется к координатам игрока. 
    
    \begin{align*}
        & |targetPoint - position|< minLength \Rightarrow\\
        & targetPoint = minLength\frac{(position - targetPoint)}{|targetPoint - position|} + position
    \end{align*}
    
    Таким образом, прицел внутри ограничевается окружностью.
    
    После этого камера вращает игрока в сторону прицела и камера начинает двигаться.
    
    \textbf{Приложение (Листинг 2: Функция передвижения камеры)}
    
    В переменных newCamX и newCamZ хранится расстояние между игроком и прицелом. 
    
    Если это расстояни больше установленного, то предполагаемый прицел, смещается на то самое установленной растояни и не больше.
    
    Таким образом, перемещение камеры ограничивается снаружи квадратом.
    
    После чего камера находит вектор между игрком и его прицелом и перемещаетя на определенный процент в этом направлении. Следственным путем было выявленно что 30\% оптимальное смещение камеры позволяющее быстро, но плавно перемещать камеру по игровому пространсту.
    
    \begin{align*}
        & cam.position = VectroTEmpo(position - targetPoint) + position
    \end{align*}
    
    \subsection*{Процедурная карта}
	\addcontentsline{toc}{subsection}{Создание процедурной карты}
	
	Следующий шаг - работа над созданием карты.
	
	Был создан объект класса MapGenerator. Объект этого класса привязывается к игроку и ходит за ним дискретными шагами, которые равны размерам комнат. 
	
	Комната состиоит из горизонатльных и вертикальных наружних стен, наружних дверей, внутренних стен, внутренних дверей, пола, покрытия пола и обоев.
	
	При генерации внутренняя и внешние части комнаты можгут быть повернуты на 180\textdegree. Из за этого может призойти так, что будет создана квартира из которой нельзя будет выйти в одном из направлений. Чтобы это исправить было решено сделать полигон для создания вунтренних стен. На этом полигоне стоят всевозможные вариации внешних стен, по этому при создании внутренностей будет видно с чем пересекаются новые стены.
	
	Далее при движении игрока проверятся расстояние между игроком и генератором, если оно по одной из координат будет больше, чем половина размера комнаты, то генератор смещается в направлении игрока на размер комнаты. 
	
	При перемещении объекта генератора сначала список комнат сортируется по расстоянию от игрока, потом он проверяет вокруг себя комнаты в переделах сетки 3x3 комнаты, и, если там отсутствует пол, удаляет самую дальнюю комнату вместе со всеми дверьми, с которыми она соприкасается. 
	
	После из различных списков выбираются различные составляющие комнат. При создании внешних стен новой квартиры проверяется, если существует квартира смежная через конкретную стену, то эта стена дублируется.
	Это необходимо для того чтобы во всей квартире были одинаковые обои. После этого туда вставляется дверь, а так же компонент, необходимый для передвижения противников сквозь двери.
	
    Так же зная что координаты игркоа хранятся в памяти компьютера как float значения, нужно помнить что на больших координатах точность ухудшается, по этому было решено, после определенной координаты, генерировать внешние стены без проходов.
	
	Дальше проверятся, какое назначение будет иметь квартира. Для этого есть список списков типов и соответствующих вероятностей появления. При запуске генератора на всякий случай сумма всех вероятностей приводится к 1.
	В прототип пока добавлены только обычная комната и комната с оружием.
	Если из списка выбирается тип, квартиры с оружием, генератор проверяет, есть ли данный тип комнаты на карте. Если такой тип присутствует, то новая квартира меняет свое назначение на обычное.
	
    Далее вызывается функция добавления внутенних дверей. В ней выбирается одна из дверей и вставляется в каждое отведенное ей место. 
    
    Дальше появляются противники. В комнате с оружием появляется оружие из списка еще не использованных. Если же этот список уже пуст, то гененрируется случайное оружие.
    
    \textbf{Приложение (Листинг 3: Генератор карты)}
    
    \subsection*{Противники}
	\addcontentsline{toc}{subsection}{Создание противников}
	При создании противников было необходимо решить, каким образом они будут передвигаться по карте. Для этого было решено использовать NavMesh. Как он работает? При создании комнаты на пол добавляется компонент поверхности для передвижения. Далее на пол раставляются внутренние стены, интерьер и временно выставляются внешние стены. Дальше поверхность смотрит, где по ней может передвигаться агент. Алгоритм этот не быстрый, поэтому желательно запекать поверхности до того, как игра будет запущена. 
	
	Предполагается что в игре будут различныйе противники, по этому было решено написать интерфейс противника, которым будем оперировать дальше.
	
    Изначально нужно заставить противников "видеть". Добавляем на сцену EnemyManager -- объект, упрявляющий npc. В нем будет храниться ссылка на противника и  всякие мелочи. Так же EnemyManager будет создавать противников. 
    
    Изначально смотрим расстояние между противником и игроком, если оно слишком большое, считаем,что игрока не видно.
    
    \begin{align*}
        &|enemy.position - target.position| > maxViewDist
    \end{align*}
    
    \textbf{Приложение (Листинг 4: Игрок слишком далеко)}
    
    Высчитываем угол между вектором, отображающим перед противника, и вектором в направлении игрока, если он по модулю больше какого-то угла, и расстояние не слишком мало, считаем, что такого игрока тоже не видим. 
    \begin{align*}
        &\left(|enemy.position - target.position| > minViewDist\right) \lor \\
        & \left(\arccos(\frac{(enemy.front, enemy.position - target.position) }{|enemy.position - target.position|}) > viewAngle\right)
    \end{align*}
    
    \textbf{Приложение (Листинг 5: Игрок слишком далеко)}
    
    Дальше пускаем луч от противника к игроку, если цель, в которую попал луч, и есть игрок, значит мы его заметили.
    
    \textbf{Приложение (Листинг 6: Игрок за преградой)}
    
    \newpage
    
Пускать лучи каждый кадр слишком тяжело и бессмысленно, так как большинство противников будут патрулировать, а там частота обновления особо не влияет. Поэтому было решено "распараллелить" эти вычисления. В EnemyManager добавлена переменная, отвечающая за число "потоков" $n$. К примеру, $n = 50$. Также там хранится массив размером $n$ , в котором хранится число противников, которые вычисляются в "потоке". И глобальный счетчик, который содержит значения от 0 до $n - 1$. Каждый кадр этот счетчик увеличивается на 1 и находится остаток от $n$. При создании противника находится "поток" с самым маленьким числом противников и высчитывается сдвиг(сколько еще FixedUpdate нужно подождать до того, чтобы посмотреть в первый раз). Теперь небольшое количество npc будет пытаться увидеть игрка. Но это работает только для патрулирования, т.к. там не особо видна эта задержка. Псевдо потоки используются в целях оптимизации.

Далее был создан ENUM в котором записанны всевозможные состояния противника, такие как патрулирование, приследование, 

    \subsection*{Оружие}
	\addcontentsline{toc}{subsection}{Создание оружия}
	
	Для оружия был написан интерфейс, в котором располагаются основные действия которые можно сделать с оружием, такие как, выстрелить, бросить, посмотреть количество патронов.
	
	Дальше был добавлен класс для оружия основанного на лучх.
	
	При выстреле из ствола оружия вылетает улч в сторону цели. После этого создается плоскость с текстурой следа от пули и если выстрел попал в объект наследующийся от класса гуманоид, то он получает урон.
	
	\section*{Заключение}
	\addcontentsline{toc}{section}{Заключение}
	
	\section*{Список литературы}
	\addcontentsline{toc}{section}{Список литературы}
	
	\newpage
	\section*{Приложение}
	\addcontentsline{toc}{section}{Приложение}
	
	 \begin{lstlisting}[caption= Основная функция камеры, label=lst:test]
    private void LookingLogic()
    {
        Plane plane = new Plane(Vector3.up, _transform.position);
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

        if (!plane.Raycast(ray, out hitDistance))
        {
            return;
        }

        targetPoint = ray.GetPoint(hitDistance);

        if (Vector3.Distance(targetPoint, transform.position) < minimalDist)
        {
            targetPoint = (targetPoint - transform.position).normalized * minimalDist + transform.position;
        }

        Vector3 targetRotation = _transform.eulerAngles;
        targetRotation.y = Quaternion.LookRotation(targetPoint - _transform.position).eulerAngles.y; 
        _transform.eulerAngles = targetRotation;

        CamMove();

    }
    \end{lstlisting}
    \newpage
    \begin{lstlisting}[caption= Функция передвижения камеры, label=lst:test]
    
    private void CamMove()
    {
        if (Mathf.Abs(targetPoint.x - _transform.position.x) < maxShotDist)
        {
            newCamX = (targetPoint.x - _transform.position.x);
        }
        else
        {
            if (targetPoint.x - _transform.position.x < 0)
                newCamX = -maxShotDist;
            else
                newCamX = maxShotDist;
        }
        newCamX = newCamX * percntsCamDist + _transform.position.x;

        if (Mathf.Abs(targetPoint.z - _transform.position.z) < maxShotDist)
        {
            newCamZ = (targetPoint.z - _transform.position.z);
        }
        else
        {
            if (targetPoint.z - _transform.position.z < 0)
                newCamZ = -maxShotDist;
            else
                newCamZ = maxShotDist;
        }
        newCamZ = newCamZ * percntsCamDist + _transform.position.z;
        cam.transform.position = Vector3.Lerp(cam.transform.position,
                                              new Vector3(
                                                  newCamX,
                                                  camY,
                                                  newCamZ),
                                              VectoroTEmpo);
    }
    \end{lstlisting}
    \newpage
    \begin{lstlisting}[caption= Генератор карты, label=lst:test]
    void MoveGenerator()
    {
        Vector3 temp = (_folowingTransform.position - _transform.position);
        //Discrete move x
        if (Mathf.Abs(temp.x) > sizeX)
        {
            
            maximilian = (int)_folowingTransform.position.x / sizeX;
            if (maximilian%2 != 0)
                maximilian += Mathf.Sign(temp.x);

            _transform.position = new Vector3(
                maximilian * sizeX,
                _transform.position.y,
                _transform.position.z
                );
            GenerateRooms();
        }
        //Discrete move z
        if (Mathf.Abs(temp.z) > sizeZ)
        {
            maximilian = (int)_folowingTransform.position.z / sizeZ;
            if (maximilian%2 != 0)
                maximilian += Mathf.Sign(temp.z);

            _transform.position = new Vector3(
                _transform.position.x,
                _transform.position.y,
                maximilian * sizeZ
                );
            GenerateRooms();
        }
    }
    
    void GenerateRooms()
    {
        generatedMap.ForEach((el1) => el1.ResetDist(_transform.position));
        generatedMap.Sort((emp2,emp1) => emp1.sDistance.CompareTo(emp2.sDistance));
        
        //Grid of rooms
        for(int i = -1; i <= 1; i++)
        {
            for(int j = -1; j <= 1; j++)
            {
                generatedRoom = GenerateRoom(i, j);
                if (!(generatedRoom is null))
                {
                    AddRoom();
                }
            }
        }
    }

    void AddRoom()
    {
        while(generatedMap.Count >= maxRoomCount)
        {
            DeleteRoom(generatedMap[0]);
            generatedMap.RemoveAt(0);
        }
        generatedMap.Add(generatedRoom);
    }
    
    RoomAndDist GenerateRoom(int iX, int iZ)
    {
        float cZ = _transform.position.z + sizeZ * iZ * 2;
        float cX = _transform.position.x + sizeX * iX * 2;
        if (Physics.OverlapBox(new Vector3(cX, 0, cZ), Vector3.one, _transform.rotation, floorLayerMask).Length > 0){
            return null;
        }
        GameObject tempRoom;
        RoomType roomType;
        tempRoom = new GameObject("room" + cX.ToString()+ ":" + cZ.ToString());
        tempRoom.transform.position = new Vector3(cX, 0, cZ);
        Material roomMat = RandomWallpaper();
        GameObject[] generatedWalls = new GameObject[5];
        generatedWalls[0] = GenerateWall(cX - sizeX + wallSize, cZ);
        generatedWalls[1] = GenerateWall(cX + sizeX - wallSize, cZ);
        generatedWalls[2] = GenerateWall(cX, cZ - sizeZ + wallSize, false);
        generatedWalls[3] = GenerateWall(cX, cZ + sizeZ - wallSize, false);
        
        float chosen = Random.Range(0f,1f);
        float sum = 0;
        int index = generationChance.Length - 1;

        for (int i = 0; i < generationChance.Length - 1; i++){
            if(chosen < generationChance[i] + sum)
                index = i;
        }

        if(index == 1 && generatedGunRoom != null){
            index = 0;
        }

        switch(index){
            case 1:
                roomType = RoomType.gunRoom;
                generatedWalls[4] = Instantiate(gunRoom, new Vector3(cX, 0, cZ), Quaternion.Euler(new Vector3(0, 0 ,0)));
                GunTable gt =  generatedWalls[4].transform.Find("gunTable").GetComponent<GunTable>();
                gt.TrigerUsed += UsedAnotherGun;
                gt.PlaceGun(GetGun());
                break;
            default:
                roomType = RoomType.simple;
                generatedWalls[4] = Instantiate(RandomMainRoomInner(), new Vector3(cX, 0, cZ), Quaternion.Euler(new Vector3(0, Random.Range(0,2) * 180 ,0)));
                break;
        }
        //End generate gunRoom

        for (int i = 0; i < generatedWalls.Length; i++)
        {
            generatedWalls[i].transform.parent = tempRoom.transform;
            for (int j = 0; j < generatedWalls[i].transform.childCount; j++)
            {
                if (generatedWalls[i].transform.GetChild(j).GetComponent<MeshRenderer>())
                {
                    generatedWalls[i].transform.GetChild(j).GetComponent<MeshRenderer>().material = roomMat;
                }
            }
        }

        AddInnerDoor(generatedWalls[4]);

        temporaryGameObj = Instantiate(floor, new Vector3(cX, 0, cZ), _transform.rotation);
        temporaryGameObj.transform.parent = tempRoom.transform;
        temporaryGameObj.GetComponent<MeshRenderer>().material = RandomFloorMaterial();
        generatedRoom = new RoomAndDist(tempRoom, _transform.position, roomType);
        
        if(roomType == RoomType.gunRoom){
            generatedGunRoom = generatedRoom.gO;
        }

        eManager.SpawnEnemys(cX,cZ);
        
        return generatedRoom;
    }

    void DeleteRoom(RoomAndDist toDel)
    {
        Collider[] col = Physics.OverlapBox(toDel.gO.transform.position, new Vector3(sizeX,1,sizeZ), _transform.rotation, LayerMask.GetMask("door", "weapon", "enemy"));
        for(int i = 0; i < col.Length; i++)
        {
            Destroy(col[i].gameObject);
        }

        //Check if inner eq to generated 
        if(toDel.gO == generatedGunRoom)
            generatedGunRoom = null;

        Destroy(toDel.gO);
    }

    GameObject GenerateWall(float x, float z, bool hor = true)
    {
        GameObject to_ret;
        Vector3 centrOfWall = new Vector3(x,0,z);
        if (Mathf.Abs(x) > MaxDist || Mathf.Abs(z) > MaxDist)
        {
            if (hor)
                to_ret = Instantiate(blockWX, centrOfWall, _transform.rotation);
            else
                to_ret = Instantiate(blockWZ, centrOfWall, _transform.rotation);
            
            
            return to_ret;
        }

        Collider[] col = Physics.OverlapBox(centrOfWall, Vector3.one, _transform.rotation, outerLayerMask);
        if (col.Length <= 0)
        {
            if (hor)
                to_ret = Instantiate(RandomXWall(), centrOfWall, _transform.rotation);
            else
                to_ret = Instantiate(RandomZWall(), centrOfWall, _transform.rotation);
            return to_ret;
        }

        to_ret = Instantiate(col[0].gameObject.transform.parent.gameObject, centrOfWall, _transform.rotation);

        for (int i = 0; i < to_ret.transform.childCount; i++)
        {
            if (to_ret.transform.GetChild(i).name == "door")
            {
                to_ret.transform.GetChild(i).Rotate(Vector3.up * (180 * Random.Range(0, 2)));

                Instantiate(link, to_ret.transform.GetChild(i).transform).transform.parent = Instantiate(RandomDoor(), to_ret.transform.GetChild(i).transform).transform; ;
            }

        }

        return to_ret;
    }


    void AddInnerDoor(GameObject wall)
    {
        for (int i = 0; i < wall.transform.childCount; i++)
        {
            if (wall.transform.GetChild(i).name == "door")
            {
                wall.transform.GetChild(i).Rotate(Vector3.up * (180 * Random.Range(0, 2)));
                
                Instantiate(RandomDoor(), wall.transform.GetChild(i).transform);
            }

        }
    }

    public void UsedAnotherGun(){
        if(weaponList.Count > 0){
            usedGuns.Add(weaponList[0]);
            eManager.guns = usedGuns;
            weaponList.RemoveAt(0);
        }
    }
    \end{lstlisting}
    \newpage
    
    
    \begin{lstlisting}[caption= Игрок слишком далеко, label=lst:test]
float distanceToTarget = Vector3.Distance(target.position, transform.position);

if (distanceToTarget > viewDistance)
{
    viewColor = Color.yellow;
    return false;
}

    \end{lstlisting}
    
    \begin{lstlisting}[caption= Игрок слишком далеко, label=lst:test]
float realAngle = Vector3.Angle(transform.forward, target.position - transform.position);
if (realAngle > viewAngle/2 && distanceToTarget > closeRange)
{
    viewColor = Color.green;
    return false;
}
    \end{lstlisting}
    
     \begin{lstlisting}[caption= Игрок за преградой, label=lst:test]
RaycastHit hit;
Ray eyeRay = new Ray(transform.position, (target.position - transform.position).normalized);

if(!Physics.Raycast(eyeRay, out hit, Mathf.Infinity))
{
    viewColor = Color.black;
    return false;
}
viewColor = Color.blue;

return hit.transform == target;

    \end{lstlisting}
    \newpage
\end{document}
